AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::LanguageExtensions'

Description: >
  Kubernetes Assessment Framework - Student Environment
  Deploys a single-node K3s cluster with Kyverno for task evaluation.
  Integrates with instructor's remote evaluation system.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Student Information"
        Parameters:
          - NeptunCode
          - TaskSelection
      - Label:
          default: "AWS Configuration"
        Parameters:
          - KeyPairName
          - InstanceType
      - Label:
          default: "Evaluation Configuration (Pre-configured by Instructor)"
        Parameters:
          - EvaluationEndpoint
          - SubmissionEndpoint
          - ApiKey

    ParameterLabels:
      NeptunCode:
        default: "Your 6-character Neptun Code (e.g., ABC123)"
      TaskSelection:
        default: "Choose your assigned task"
      KeyPairName:
        default: "SSH Key Pair Name"
      InstanceType:
        default: "EC2 Instance Type"
      EvaluationEndpoint:
        default: "Evaluation Lambda Endpoint"
      SubmissionEndpoint:
        default: "Submission Lambda Endpoint"
      ApiKey:
        default: "API Key"

Parameters:
  NeptunCode:
    Type: String
    MinLength: 6
    MaxLength: 6
    AllowedPattern: '[A-Za-z0-9]{6}'
    Description: Your unique 6-character Neptun Code (e.g., ABC123)
    ConstraintDescription: Must be exactly 6 alphanumeric characters

  TaskSelection:
    Type: String
    Default: 'task-01'
    AllowedValues:
      - task-01
      - task-02
      - task-03
      - task-04
      - task-05
    Description: Select the task assigned to you by your instructor
    ConstraintDescription: Choose your assigned task

  KeyPairName:
    Type: AWS::EC2::KeyPair::KeyName
    Default: 'vockey'
    Description: Name of an existing EC2 KeyPair (usually 'vockey' in AWS Learner Lab)
    ConstraintDescription: Must be the name of an existing EC2 KeyPair

  InstanceType:
    Type: String
    Default: t3.medium
    AllowedValues:
      - t3.small
      - t3.medium
      - t3.large
    Description: EC2 instance type for K3s server
    ConstraintDescription: Must be a valid EC2 instance type

  EvaluationEndpoint:
    Type: String
    Default: ''
    Description: Lambda function URL for evaluation (pre-configured by instructor)

  SubmissionEndpoint:
    Type: String
    Default: ''
    Description: Lambda function URL for submission (pre-configured by instructor)

  ApiKey:
    Type: String
    NoEcho: true
    Default: ''
    Description: API key for authentication (pre-configured by instructor)

Mappings:
  TaskConfiguration:
    task-01:
      Name: "Deploy NGINX Web Application"
      Description: "Create a scalable NGINX deployment with 3 replicas and resource limits"
      GitHubPath: "tasks/task-01"
    task-02:
      Name: "Service and Ingress Configuration"
      Description: "Expose applications using Kubernetes services and ingress controllers"
      GitHubPath: "tasks/task-02"
    task-03:
      Name: "ConfigMaps and Secrets"
      Description: "Manage application configuration using ConfigMaps and Secrets"
      GitHubPath: "tasks/task-03"
    task-04:
      Name: "ConfigMaps, Secrets, and Resource Management"
      Description: "Configure resources with ConfigMaps, Secrets, and resource limits"
      GitHubPath: "tasks/task-04"
    task-05:
      Name: "StatefulSet with Persistent Storage"
      Description: "Deploy stateful applications using StatefulSets and persistent volumes"
      GitHubPath: "tasks/task-05"

Resources:
  # VPC Configuration
  StudentVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: !Sub 'k8s-student-${NeptunCode}-vpc'

  StudentInternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub 'k8s-student-${NeptunCode}-igw'

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref StudentVPC
      InternetGatewayId: !Ref StudentInternetGateway

  StudentPublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref StudentVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select
        - 0
        - !GetAZs ''
      Tags:
        - Key: Name
          Value: !Sub 'k8s-student-${NeptunCode}-public-subnet'

  StudentRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref StudentVPC
      Tags:
        - Key: Name
          Value: !Sub 'k8s-student-${NeptunCode}-rt'

  StudentPublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref StudentRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref StudentInternetGateway

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref StudentPublicSubnet
      RouteTableId: !Ref StudentRouteTable

  # Security Group
  StudentSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub 'k8s-student-${NeptunCode}-sg'
      GroupDescription: Security group for K8s student environment
      VpcId: !Ref StudentVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
          Description: SSH access
        - IpProtocol: tcp
          FromPort: 6443
          ToPort: 6443
          CidrIp: 0.0.0.0/0
          Description: Kubernetes API server
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: HTTP for Ingress
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS for Ingress
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub 'k8s-student-${NeptunCode}-sg'

  # IAM Role for EC2 (using LabRole for AWS Learner Lab compatibility)
  StudentInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - LabRole

  # EC2 Instance
  StudentK3sInstance:
    Type: AWS::EC2::Instance
    DependsOn:
      - StudentPublicRoute
    Properties:
      ImageId: !Sub '{{resolve:ssm:/aws/service/canonical/ubuntu/server/22.04/stable/current/amd64/hvm/ebs-gp2/ami-id}}'
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyPairName
      IamInstanceProfile: !Ref StudentInstanceProfile
      NetworkInterfaces:
        - AssociatePublicIpAddress: true
          DeviceIndex: 0
          GroupSet:
            - !Ref StudentSecurityGroup
          SubnetId: !Ref StudentPublicSubnet
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: 20
            VolumeType: gp3
            DeleteOnTermination: true
      Tags:
        - Key: Name
          Value: !Sub 'k8s-student-${NeptunCode}'
        - Key: NeptunCode
          Value: !Ref NeptunCode
        - Key: Task
          Value: !Ref TaskSelection
        - Key: AutoShutdown
          Value: '4h'
      UserData:
        Fn::Base64: !Sub
          - |
            #!/bin/bash
            set -x
            exec > >(tee /var/log/user-data.log)
            exec 2>&1

            echo "=== K8s Assessment Framework - Student Environment Setup ==="
            echo "Neptun Code: ${NeptunCode}"
            echo "Task: ${TaskSelection}"
            echo "Task Name: ${TaskName}"

            # Update system
            apt-get update
            apt-get install -y curl wget git jq

            # Install Docker
            echo "Installing Docker..."
            apt-get install -y docker.io
            systemctl enable docker
            systemctl start docker
            usermod -aG docker ubuntu

            # Install K3s
            echo "Installing K3s..."
            curl -sfL https://get.k3s.io | sh -s - \
              --write-kubeconfig-mode 644 \
              --disable traefik \
              --disable servicelb

            # Wait for K3s to be ready
            echo "Waiting for K3s to be ready..."
            sleep 30
            until kubectl get nodes 2>/dev/null; do
              echo "Waiting for K3s..."
              sleep 5
            done

            # Build test-runner image locally (to reduce S3 costs)
            echo "Building test-runner image locally..."
            mkdir -p /tmp/test-runner-build

            # Create test_runner.py
            cat > /tmp/test-runner-build/test_runner.py <<'EOFTESTRUNNER'
            #!/usr/bin/env python3
            """
            Test Runner Pod - Executes application-level checks inside student cluster
            Runs HTTP endpoint tests, data persistence checks, and graceful shutdown validation
            """

            import json
            import sys
            import os
            import requests
            import time
            from datetime import datetime


            class TestRunner:
                def __init__(self, checks):
                    self.checks = checks
                    self.results = {}

                def run_all_checks(self):
                    """
                    Execute all checks defined in the test specification
                    """
                    for check in self.checks:
                        check_id = check['check_id']
                        check_type = check['check_type']

                        print(f"Running check: {check_id} (type: {check_type})")

                        try:
                            if check_type == 'http_get':
                                result = self.http_get_check(check)
                            elif check_type == 'http_post':
                                result = self.http_post_check(check)
                            elif check_type == 'data_persistence':
                                result = self.data_persistence_check(check)
                            elif check_type == 'graceful_shutdown':
                                result = self.graceful_shutdown_check(check)
                            else:
                                print(f"Unknown check type: {check_type}")
                                result = {
                                    'passed': False,
                                    'message': f'Unknown check type: {check_type}'
                                }

                            self.results[check_id] = result

                        except Exception as e:
                            print(f"Error running check {check_id}: {e}")
                            self.results[check_id] = {
                                'passed': False,
                                'message': str(e)
                            }

                    return self.results

                def http_get_check(self, check):
                    """
                    Perform HTTP GET request and validate response
                    """
                    service = check.get('service')
                    port = check.get('port', 80)
                    path = check.get('path', '/')
                    namespace = check.get('namespace', 'default')
                    target_pod = check.get('target_pod')
                    expected_status = check.get('expected_status', 200)
                    expected_body_contains = check.get('expected_body_contains')
                    expected_json_fields = check.get('expected_json_fields', [])
                    timeout = check.get('timeout', 30)

                    # Build URL (cluster-internal)
                    if target_pod:
                        url = f'http://{target_pod}.{service}.{namespace}.svc.cluster.local:{port}{path}'
                    else:
                        url = f'http://{service}.{namespace}.svc.cluster.local:{port}{path}'

                    print(f"  GET {url}")

                    try:
                        response = requests.get(url, timeout=timeout)

                        # Check status code
                        status_ok = (response.status_code == expected_status)

                        # Check body contains expected string
                        body_ok = True
                        if expected_body_contains:
                            body_ok = expected_body_contains in response.text

                        # Check JSON fields
                        json_ok = True
                        if expected_json_fields:
                            try:
                                data = response.json()
                                json_ok = all(field in data for field in expected_json_fields)
                            except:
                                json_ok = False

                        passed = status_ok and body_ok and json_ok

                        return {
                            'passed': passed,
                            'status_code': response.status_code,
                            'status_ok': status_ok,
                            'body_ok': body_ok,
                            'json_ok': json_ok,
                            'message': f'Status: {response.status_code}, Body check: {body_ok}, JSON check: {json_ok}'
                        }

                    except requests.exceptions.Timeout:
                        return {
                            'passed': False,
                            'message': f'Request timeout after {timeout}s'
                        }
                    except requests.exceptions.ConnectionError as e:
                        return {
                            'passed': False,
                            'message': f'Connection error: {str(e)}'
                        }
                    except Exception as e:
                        return {
                            'passed': False,
                            'message': f'Error: {str(e)}'
                        }

                def http_post_check(self, check):
                    """
                    Perform HTTP POST request and validate response
                    """
                    service = check.get('service')
                    port = check.get('port', 80)
                    path = check.get('path', '/')
                    namespace = check.get('namespace', 'default')
                    target_pod = check.get('target_pod')
                    body = check.get('body', '')
                    expected_status = check.get('expected_status', 200)
                    timeout = check.get('timeout', 30)

                    # Build URL
                    if target_pod:
                        url = f'http://{target_pod}.{service}.{namespace}.svc.cluster.local:{port}{path}'
                    else:
                        url = f'http://{service}.{namespace}.svc.cluster.local:{port}{path}'

                    print(f"  POST {url}")

                    try:
                        response = requests.post(url, data=body, timeout=timeout)

                        status_ok = (response.status_code == expected_status)

                        return {
                            'passed': status_ok,
                            'status_code': response.status_code,
                            'message': f'Status: {response.status_code}'
                        }

                    except requests.exceptions.Timeout:
                        return {
                            'passed': False,
                            'message': f'Request timeout after {timeout}s'
                        }
                    except Exception as e:
                        return {
                            'passed': False,
                            'message': f'Error: {str(e)}'
                        }

                def data_persistence_check(self, check):
                    """
                    Check data persistence by storing, restarting pod, and retrieving
                    """
                    steps = check.get('validation_steps', [])
                    namespace = check.get('namespace', 'default')

                    print(f"  Running data persistence test with {len(steps)} steps")

                    # This is a complex check that would need kubectl access
                    # For now, return a placeholder
                    return {
                        'passed': False,
                        'message': 'Data persistence check requires kubectl access (not implemented yet)'
                    }

                def graceful_shutdown_check(self, check):
                    """
                    Check graceful shutdown behavior
                    """
                    steps = check.get('validation_steps', [])

                    print(f"  Running graceful shutdown test with {len(steps)} steps")

                    # This is a complex check that would need kubectl access
                    return {
                        'passed': False,
                        'message': 'Graceful shutdown check requires kubectl access (not implemented yet)'
                    }


            def main():
                """
                Main entry point - reads checks from environment variable and outputs results to stdout
                """
                print("Test Runner Starting...")
                print(f"Time: {datetime.utcnow().isoformat()}")

                try:
                    # Read checks from environment variable (passed by Lambda)
                    test_spec_json = os.environ.get('TEST_SPEC')

                    if not test_spec_json:
                        raise Exception("TEST_SPEC environment variable not set")

                    checks_spec = json.loads(test_spec_json)

                    checks = checks_spec.get('checks', [])
                    print(f"Loaded {len(checks)} checks")

                    # Run all checks
                    runner = TestRunner(checks)
                    results = runner.run_all_checks()

                    # Output results as JSON to stdout
                    output = {
                        'success': True,
                        'timestamp': datetime.utcnow().isoformat(),
                        'results': results
                    }

                    print("\n=== TEST RESULTS ===")
                    print(json.dumps(output))

                except Exception as e:
                    print(f"Fatal error: {e}", file=sys.stderr)
                    output = {
                        'success': False,
                        'error': str(e)
                    }
                    print(json.dumps(output))
                    sys.exit(1)


            if __name__ == '__main__':
                main()
            EOFTESTRUNNER

            # Create Dockerfile
            cat > /tmp/test-runner-build/Dockerfile <<'EOFDOCKERFILE'
            FROM python:3.11-slim

            WORKDIR /app

            # Install required packages
            RUN pip install --no-cache-dir requests==2.31.0

            # Copy test runner
            COPY test_runner.py /app/test_runner.py
            RUN chmod +x /app/test_runner.py

            # Run as non-root user
            RUN useradd -m -u 1000 testrunner
            USER testrunner

            ENTRYPOINT ["python3", "/app/test_runner.py"]
            EOFDOCKERFILE

            # Build the image
            echo "Building test-runner Docker image..."
            docker build -t test-runner:latest /tmp/test-runner-build

            # Import into K3s
            echo "Importing test-runner image into K3s..."
            docker save test-runner:latest | k3s ctr images import - && \
              echo "‚úÖ test-runner:latest built and imported successfully" || \
              echo "‚ùå Failed to build/import test-runner image"

            # Cleanup build directory
            rm -rf /tmp/test-runner-build

            # Download other Docker images from S3 (for specific tasks)
            echo "Downloading task-specific Docker images from S3..."
            IMAGES_BUCKET="k8s-assessment-templates"
            IMAGES_PREFIX="docker-images"

            # Download kvstore image (for task-02)
            echo "Downloading kvstore image..."
            wget -q -O /tmp/kvstore.tar "https://${!IMAGES_BUCKET}.s3.us-east-1.amazonaws.com/${!IMAGES_PREFIX}/kvstore.tar" || \
              echo "Warning: kvstore image not found in S3, skipping..."

            # Download backend image (for task-03)
            echo "Downloading backend image..."
            wget -q -O /tmp/backend.tar "https://${!IMAGES_BUCKET}.s3.us-east-1.amazonaws.com/${!IMAGES_PREFIX}/backend.tar" || \
              echo "Warning: backend image not found in S3, skipping..."

            # Download frontend image (for task-03)
            echo "Downloading frontend image..."
            wget -q -O /tmp/frontend.tar "https://${!IMAGES_BUCKET}.s3.us-east-1.amazonaws.com/${!IMAGES_PREFIX}/frontend.tar" || \
              echo "Warning: frontend image not found in S3, skipping..."

            # Import task-specific images into K3s
            echo "Importing task-specific Docker images into K3s..."

            if [ -f /tmp/kvstore.tar ]; then
              k3s ctr images import /tmp/kvstore.tar && \
                echo "‚úÖ kvstore:latest imported successfully" || \
                echo "‚ùå Failed to import kvstore image"
              rm -f /tmp/kvstore.tar
            fi

            if [ -f /tmp/backend.tar ]; then
              k3s ctr images import /tmp/backend.tar && \
                echo "‚úÖ backend:latest imported successfully" || \
                echo "‚ùå Failed to import backend image"
              rm -f /tmp/backend.tar
            fi

            if [ -f /tmp/frontend.tar ]; then
              k3s ctr images import /tmp/frontend.tar && \
                echo "‚úÖ frontend:latest imported successfully" || \
                echo "‚ùå Failed to import frontend image"
              rm -f /tmp/frontend.tar
            fi

            # List imported images for verification
            echo "Available images in K3s:"
            k3s ctr images ls | grep -E "test-runner|kvstore|backend|frontend" || echo "No custom images found"

            # Create task namespace
            echo "Creating task namespace: ${TaskSelection}..."
            kubectl create namespace ${TaskSelection}

            # Create service account for remote evaluation
            echo "Creating service account for remote evaluation..."
            kubectl create serviceaccount evaluator-sa -n default
            kubectl create clusterrolebinding evaluator-sa-binding \
              --clusterrole=cluster-admin \
              --serviceaccount=default:evaluator-sa

            # Get service account token
            kubectl apply -f - <<EOF
            apiVersion: v1
            kind: Secret
            metadata:
              name: evaluator-sa-token
              namespace: default
              annotations:
                kubernetes.io/service-account.name: evaluator-sa
            type: kubernetes.io/service-account-token
            EOF

            # Wait for token to be created
            sleep 5

            # Store cluster info for evaluation
            KUBE_TOKEN=$(kubectl get secret evaluator-sa-token -n default -o jsonpath='{.data.token}' | base64 -d)
            PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
            # Use public IP instead of 127.0.0.1 for remote access
            KUBE_API="https://$PUBLIC_IP:6443"

            # Store credentials in home directory
            mkdir -p /home/ubuntu/.kube-assessment
            cat > /home/ubuntu/.kube-assessment/cluster-info.json <<EOFCLUSTER
            {
              "neptun_code": "${NeptunCode}",
              "task_id": "${TaskSelection}",
              "kube_api": "$KUBE_API",
              "kube_token": "$KUBE_TOKEN",
              "public_ip": "$PUBLIC_IP"
            }
            EOFCLUSTER

            chown -R ubuntu:ubuntu /home/ubuntu/.kube-assessment
            chmod 600 /home/ubuntu/.kube-assessment/cluster-info.json

            # Create task workspace (no git clone needed)
            echo "Setting up task workspace..."
            mkdir -p /home/ubuntu/k8s-workspace/tasks/${TaskSelection}

            # Create task README
            cat > /home/ubuntu/k8s-workspace/tasks/${TaskSelection}/README.md <<EOFTASKREADME
            # Task 01: Deploy NGINX Web Application

            ## Objective
            Deploy a scalable NGINX web application with proper Kubernetes resources.

            ## Requirements

            1. **Deployment**:
               - Name: `nginx-web`
               - Namespace: `${TaskSelection}`
               - Replicas: 2
               - Container image: `nginx:latest`
               - Container port: 80

            2. **Service**:
               - Name: `nginx-service`
               - Type: NodePort
               - Port: 80
               - NodePort: 30080
               - Selector: `app: nginx`

            3. **Labels**:
               - All resources must have label: `app: nginx`

            ## Validation Criteria

            Your solution will be evaluated for:
            - ‚úÖ Deployment exists with correct name and namespace
            - ‚úÖ Deployment has 2 replicas running
            - ‚úÖ Pods are running and ready
            - ‚úÖ Service exists and is accessible
            - ‚úÖ Correct labels applied

            ## How to Complete

            1. Create your solution YAML file(s) in this directory
            2. Apply your solution: `kubectl apply -f your-solution.yaml`
            3. Verify it works: `kubectl get all`
            4. Request evaluation: `kubeafr eval ${TaskSelection}`
            5. Review results and fix any issues
            6. Submit when ready: `kubeafr submit ${TaskSelection}`

            **Tip:** You can also use shortcuts: `eval ${TaskSelection}` or `submit ${TaskSelection}`

            ## Example Solution Structure

            ```yaml
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: nginx-web
              namespace: ${TaskSelection}
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: nginx
              template:
                metadata:
                  labels:
                    app: nginx
                spec:
                  containers:
                  - name: nginx
                    image: nginx:latest
                    ports:
                    - containerPort: 80
            ---
            apiVersion: v1
            kind: Service
            metadata:
              name: nginx-service
              namespace: ${TaskSelection}
            spec:
              type: NodePort
              selector:
                app: nginx
              ports:
              - port: 80
                targetPort: 80
                nodePort: 30080
            ```

            Good luck!
            EOFTASKREADME

            chown -R ubuntu:ubuntu /home/ubuntu/k8s-workspace

            # Install kubeafr CLI tool for students
            echo "Installing kubeafr CLI..."
            TEMPLATES_BUCKET="k8s-assessment-templates"

            # Download kubeafr from S3
            wget -q -O /tmp/kubeafr "https://${!TEMPLATES_BUCKET}.s3.us-east-1.amazonaws.com/tools/kubeafr" || \
              echo "Warning: kubeafr not found in S3, skipping CLI installation..."

            if [ -f /tmp/kubeafr ]; then
              # Install to /usr/local/bin
              mv /tmp/kubeafr /usr/local/bin/kubeafr
              chmod +x /usr/local/bin/kubeafr
              echo "‚úÖ kubeafr CLI installed to /usr/local/bin/kubeafr"

              # Set up environment variables for student commands
              cat >> /home/ubuntu/.bashrc << 'EOFBASHRC'
            # Kubernetes Assessment Framework environment
            export EVAL_ENDPOINT="${EvaluationEndpoint}"
            export SUBMIT_ENDPOINT="${SubmissionEndpoint}"
            export API_KEY="${ApiKey}"
            # kubeafr CLI
            alias eval="kubeafr eval"
            alias submit="kubeafr submit"
            alias k8s-status="kubeafr status"
            alias k8s-tasks="kubeafr tasks"
            EOFBASHRC

              # Replace placeholders in .bashrc
              sed -i "s|\${EvaluationEndpoint}|${EvaluationEndpoint}|g" /home/ubuntu/.bashrc
              sed -i "s|\${SubmissionEndpoint}|${SubmissionEndpoint}|g" /home/ubuntu/.bashrc
              sed -i "s|\${ApiKey}|${ApiKey}|g" /home/ubuntu/.bashrc

              chown ubuntu:ubuntu /home/ubuntu/.bashrc

              echo "‚úÖ Environment configured for kubeafr"
            fi

            # Create backward compatibility scripts (for existing documentation)
            mkdir -p /home/ubuntu/student-tools

            cat > /home/ubuntu/student-tools/request-evaluation.sh <<'EOFEVAL'
            #!/bin/bash
            echo "Note: This script is deprecated. Use 'kubeafr eval <task-id>' instead."
            echo ""
            /usr/local/bin/kubeafr eval "$@"
            EOFEVAL

            cat > /home/ubuntu/student-tools/submit-final.sh <<'EOFSUBMIT'
            #!/bin/bash
            echo "Note: This script is deprecated. Use 'kubeafr submit <task-id>' instead."
            echo ""
            /usr/local/bin/kubeafr submit "$@"
            EOFSUBMIT

            chmod +x /home/ubuntu/student-tools/*.sh
            chown -R ubuntu:ubuntu /home/ubuntu/student-tools

            # Create welcome message
            cat > /home/ubuntu/welcome.txt <<EOFWELCOME
            ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
            ‚ïë   Kubernetes Assessment Framework - Student Environment      ‚ïë
            ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

            Welcome, ${NeptunCode}!

            Your Task: ${TaskSelection} - ${TaskName}

            üìÅ Workspace Location:
               ~/k8s-workspace/tasks/${TaskSelection}/

            üõ†Ô∏è  kubeafr CLI Commands:
               kubeafr eval <task-id>          # Request evaluation
               kubeafr submit <task-id>        # Submit final solution
               kubeafr status                  # Check environment
               kubeafr tasks                   # List available tasks

            üí° Shortcuts (aliases):
               eval ${TaskSelection}              # Quick evaluation
               submit ${TaskSelection}            # Quick submission

            üìã Quick Start:
               1. cd ~/k8s-workspace/tasks/${TaskSelection}
               2. cat README.md
               3. Create your solution YAML files
               4. kubectl apply -f your-solution.yaml
               5. kubeafr eval ${TaskSelection}
               6. Review results and iterate
               7. kubeafr submit ${TaskSelection}

            ‚è∞ Environment Lifetime: 4 hours
               Save your work regularly!

            üîç Useful Commands:
               kubectl get all                 # View all resources
               kubectl describe <resource>     # Detailed info
               kubectl logs <pod-name>         # View logs
               kubeafr help                    # Show all commands
               kubeafr version                 # CLI version

            Good luck with your assessment!
            EOFWELCOME

            chown ubuntu:ubuntu /home/ubuntu/welcome.txt

            # Display welcome message on login
            echo "cat /home/ubuntu/welcome.txt" >> /home/ubuntu/.bashrc

            # Set up auto-shutdown after 4 hours
            echo "sudo shutdown -h +240" | at now

            echo "=== Setup Complete ==="
            echo "Environment ready for ${NeptunCode}"
          - TaskName: !FindInMap [TaskConfiguration, !Ref TaskSelection, Name]

Outputs:
  PublicIP:
    Description: Public IP address of your K8s environment
    Value: !GetAtt StudentK3sInstance.PublicIp
    Export:
      Name: !Sub '${AWS::StackName}-PublicIP'

  SSHCommand:
    Description: SSH command to connect to your environment
    Value: !Sub 'ssh -i ~/.ssh/${KeyPairName}.pem ubuntu@${StudentK3sInstance.PublicIp}'

  TaskAssignment:
    Description: Your assigned task
    Value: !Sub
      - '${TaskSelection}: ${TaskName}'
      - TaskName: !FindInMap [TaskConfiguration, !Ref TaskSelection, Name]

  WorkspaceLocation:
    Description: Location of your task workspace
    Value: !Sub
      - '~/k8s-workspace/tasks/${TaskSelection}/'
      - {}

  EvaluationCommand:
    Description: Command to request evaluation
    Value: !Sub 'kubeafr eval ${TaskSelection}'

  SubmissionCommand:
    Description: Command to submit final results
    Value: !Sub 'kubeafr submit ${TaskSelection}'

  EnvironmentLifetime:
    Description: Auto-shutdown time
    Value: '4 hours from creation'
